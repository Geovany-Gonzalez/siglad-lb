# -----------------------------
# NGINX open-source - Load Balancer for SIGLAD
# -----------------------------

worker_processes auto;
events { worker_connections 1024; }

http {
  # --- Logs (deben ir en http) ---
  log_format main  '$remote_addr - $remote_user [$time_local] "$request" '
                   'status=$status bytes=$body_bytes_sent '
                   'rt=$request_time ref="$http_referer" ua="$http_user_agent" '
                   'upstream="$upstream_addr" ustatus="$upstream_status" urt="$upstream_response_time" host="$host"';

  access_log /var/log/nginx/access.log main;
  error_log  /var/log/nginx/error.log warn;

  # Ajustes básicos
  sendfile on;
  tcp_nopush on;
  keepalive_timeout 65;
  resolver 1.1.1.1 1.0.0.1 valid=30s ipv6=off;

  # --- Upstreams (50/50 por pesos) ---
  upstream siglad_fronts {
    # Render sirve HTTPS en 443; usamos 'resolve' para refrescar DNS dinámico
    server siglad-proyecto.onrender.com:443    weight=1 max_fails=1 fail_timeout=10s;
    server siglad-proyectoii.onrender.com:443  weight=1 max_fails=1 fail_timeout=10s;
    keepalive 16;
  }

  server {
    listen 8080;                 # Render expone el contenedor en $PORT
    server_name _;

    # --- Salud simple para Render ---
    location = /_lb/health { return 200 'OK'; add_header Content-Type text/plain; }

    # --- Saber qué backend respondió (muestra $upstream_addr) ---
    location = /_lb/which {
      # Forzamos una solicitud muy barata para que NGINX seleccione upstream
      internal;
    }

    # Página legible que llama al interno
    location = /_lb/which {
      proxy_method GET;
      proxy_pass https://siglad_fronts/;  # hace selección y rellena $upstream_addr
      proxy_set_header Host $host;
      proxy_ssl_server_name on;
      proxy_http_version 1.1;
      proxy_set_header Connection "";
      # Tras la selección, devolvemos el upstream elegido
      proxy_intercept_errors on;
      error_page 301 302 307 308 200 = @echo_upstream;
    }

    location @echo_upstream {
      default_type text/plain;
      return 200 $upstream_addr;
    }

    # --- Balanceo para todo el sitio (frontend) ---
    location / {
      # TLS hacia Render (los upstreams están en 443)
      proxy_pass https://siglad_fronts;
      proxy_ssl_server_name on;

      # Encabezados habituales
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_http_version 1.1;
      proxy_set_header Connection "";

      # Failover rápido cuando un backend falla o tarda
      proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
      proxy_next_upstream_tries 2;
      proxy_connect_timeout 3s;
      proxy_read_timeout 15s;
      proxy_send_timeout 15s;
    }
  }
}
